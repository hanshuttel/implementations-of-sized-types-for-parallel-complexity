%\chapter{Constraint judgements}\label{sec:verjudgeprob}

% A constraint $I \bowtie J$ on $\varphi$ is satisfied given an index valuation $\rho : \varphi \rightarrow \mathbb{N}$ when $[\![I]\!]_\rho \bowtie [\![J]\!]_\rho$ is satisfied, denoted $\rho \vDash I \bowtie J$. For a finite set of constraints $\Phi$, we write $\rho\vDash \Phi$ when $\rho \vDash C$ holds for all $C \in \Phi$. Finally, $\varphi;\Phi\vDash C$ holds when for all index valuations $\rho$ such that $\rho\vDash \Phi$ holds, we also have $\rho\vDash C$. That is, $\varphi;\Phi\vDash C$ holds exactly when $C$ does not impose further restrictions on index valuations on $\varphi$. Such judgements are fundamental to the type system by Baillot and Ghyselen, especially ones of the form $\varphi;\Phi\vDash I \leq J$, as they impose a partial order on indices wrt. how indices may be interpreted. This enables a notion of subtyping for parametric complexities, such that only indices that are greater or equal may substitute, thus preserving upper bounds on the global parallel complexity.\\ 
%As presented in Chapter \ref{ch:typecheck}, verifying judgements on constraints is an important problem to consider during type checking. In this chapter we give a more detailed description and intuition of what it means for constraint judgements to be satisfied, as well as show how constraint judgements for linear constraints can be checked using linear programming. For this we need to take special care of the special \textit{monus} operator used in the type system, as the behavior of this is not consistent with the behavior of the usual minus used in linear programming problems. We also show how a certain subset of polynomial constraints can be reduced to linear constraints by constructing linear constraints with the same properties as the polynomial constraint, such that these can also be verified using the same method.
%A number of interesting problems arise when considering parallel complexity compared to sequential complexity. One of such problems is the fact that if two processes are run in parallel, their combined complexity, which may be parametric in the size(s) of one or more inputs, is not the sum of their individual complexities, as is the case with sequential processes, but instead it is the maximum of the two. It is also relevant to sometimes consider certain facts about processes when considering their complexity, such as the maximum or minimum value of an expression. These facts, expressed as constraints, may be used when checking e.g. if one complexity bounds another complexity. The goal of this chapter is to first set up a syntax for \textit{indices}, which represent expressions describing complexities, which we will use to set up a syntax for \textit{constraints} describing facts about minimum or maximum sizes of expressions. We give both a predicate logic and a model-theoretic interpretation of such judgements. Using these judgements, we show how we can mechanically verify if one constraint always holds given a set of other constraints, referred to as \textit{constraint judgements}. We first show how we can verify linear constraint judgements  using linear programming, after which we show how we can reduce a certain subset of polynomial constraints to linear ones.

%\input{sections/constraint_judgements/indices}
%\input{sections/constraint_judgements/alternative_formulations}
%\input{sections/constraint_judgements/undecidability_polynomial}
%\input{sections/constraint_judgements/verifying_linear_judgements}
%\input{sections/constraint_judgements/verifying_polynomial_judgements}
%\input{sections/constraint_judgements/verifying_univariate_judgements}