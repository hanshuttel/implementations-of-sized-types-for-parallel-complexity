\chapter{Type checking sized types for parallel complexity}\label{ch:typecheck}
As mentioned in Chapter \ref{ch:bgts}, Baillot and Ghyselen \cite{BaillotGhyselen2021} bound sizes of algebraic terms and synchronizations on channels using indices, leading to a partial order on indices. For instance, for a process of the form $\inputch{a}{v}{}{\asyncoutputch{b}{v}{}} \mid P$ (assuming synchronizations induce a cost in time complexity of one) we must enforce that the bound on $a$ is strictly smaller than the bound on $b$. Thus, we must impose constraints on the interpretations of indices. Another concern in the typing of the process above is the parallel complexity. Granted separate bounds on the complexities of $\inputch{a}{v}{}{\asyncoutputch{b}{v}{}}$ and $P$, how do we establish a tight bound on their parallel composition? This turns out to be another major challenge, as bounds may be parametric, such that comparison of bounds is a partial order. Finally, for a process of the form $!\inputch{a}{v}{}{P} \mid \asyncoutputch{a}{e}{}$ we must \textit{instantiate} the parametric complexity of $!\inputch{a}{v}{}{P}$ based on the deducible size bounds of $e$, which quickly becomes difficult as indices become more complex.\\ % As the type system is otherwise fairly standard, for instance using input/output types for channels, the challenge in introducing type check is to ensure constraints on indices are not violated.\\
%
%Type inference for the type system introduced in Baillot and Ghyselen \cite{BaillotGhyselen2021} is complicated by similar challenges to that of type checking, such as constraint satisfaction. Another concern with respect to sized types is that we must infer indices. Here, it is relevant to consider existing work on sized type inference, such as Hughes et al. \cite{HughesEtAl1996} and Avanzini and Dal Lago \cite{AvanziniLago2017}. The set of function symbols used to form indices should be be more strictly defined, to make inference tractable. We also must be careful with respect to recursion, predominantly with how primitive recursion can be identified. In this chapter, we address some of these challenges.
%
% The type system for parallel complexity of message-passing processes introduced in Baillot and Ghyselen \cite{BaillotGhyselen2021} uses sized types to express parametric complexity of invoking replicated inputs, and thereby achieve precise bounds on primitively recursive processes. This requires a notion of polymorphism in the message types of replicated inputs. Baillot and Ghyselen introduce size polymorphism by bounding sizes of algebraic terms and synchronizations on channels with algebraic expressions referred to as indices that may contain index variables representing unknown sizes. We may interpret an index with an index valuation that maps its index variables to naturals, such that the index may be evaluated.\\ %
%
% The bounds on sizes and synchronizations lead to a partial order on indices. For instance, for a process of the form $\inputch{a}{v}{}{\asyncoutputch{b}{v}{}} \mid P$ (assuming synchronizations induce a cost in time complexity of one) we must enforce that the bound on $a$ is strictly smaller than the bound on $b$. Thus, we must induce constraints on the interpretations of indices. As the type system is otherwise fairly standard, for instance using input/output types for channels, the challenge in introducing type check is to ensure constraints on indices are not violated.

The purpose of this section is to present a version of the type system by Baillot and Ghyselen that is algorithmic in the sense that its type rules can be easily implemented in a programming language, and so we must address the challenges described above. For the type checker, we assume we are given a set of constraints $\Phi$ on index variables in $\varphi$ and a type environment $\Gamma$. We first present the types of the type system as well as subtyping. Afterwards, we present auxiliary functions and type rules. For the type rules we also present the concept of combined complexities that we use to bound parallel complexities by deferring comparisons of indices when these are not defined. We then prove the soundness of the type checker and show how it can be extended accompanied by examples. Finally, we show how we can verify the constraint judgements that show up in the type rules.

\input{sections/typecheck/aux_functions}
\input{sections/typecheck/type_rules}
\input{sections/typecheck/soundness}
\input{sections/typecheck/verifying_linear_judgements}
\input{sections/typecheck/verifying_polynomial_judgements}
\input{sections/typecheck/verifying_univariate_judgements}
\input{sections/typecheck/examples}
