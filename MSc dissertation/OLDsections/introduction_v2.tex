\chapter{Introduction}
Computational complexity is the study of analyzing the amount of resources required to execute an algorithm or program. Here, resources typically refer to either the termination time or the space (or memory) required to store intermediate results during run-time. As the termination time is machine specific, an abstract notion of time, such as the number of integer comparisons or additions required is most often considered. Both the time and space complexity of an algorithm depend on the size of their inputs, so complexity is typically expressed as a function of the input size. With regards to parametric complexity, we may be interested in either the worst-case (the maximum amount of resources required over all possible inputs), average-case (the average amount of resources required over all inputs) or best-case (the minimum amount of resources required over all inputs) complexity. Complexity analysis is usually static, i.e. it is performed without executing the target algorithm or program, and this is typically a manual endeavor. More recently, type systems have been used in the study of static complexity analysis to introduce type systems, for which bounds on the complexities of well-typed programs can be derived from their typings, thereby \textit{mechanizing} the analysis.\\
%
%***Static complexity analysis ---> from manual to automatic type based approaches***\\

Type systems are formal methods comprising of sets of rules that perform classification on values in a program, by assigning types to its constituents. Programs that satisfy the rules of a type system are said to be well-typed, usually meaning that such programs are well-behaved, with respect to some property typically defined based on the semantics, such as \textit{well-typed programs do not go wrong} \cite{Milner1978}. In the study of type-based static complexity analysis, type systems have the advantage that they are typically compositional, meaning they can more easily be extended, are more comprehensible, and are simpler to prove correctness of. Therefore, type systems are typically formally grounded, and can thus verify the correctness of complexity analyses. Provided an inference algorithm, we can also use the type system to infer bounds on the complexities of well-typed programs directly.\\

We distinguish between static complexity analysis of sequential and concurrent programs. With regards to concurrent programs, we may be interested in either the sequential complexity (also called the \textit{work}), or the parallel complexity (also called the \textit{span}), where we assume infinitely many processors and maximize the parallelism. The parallel complexity is more difficult to analyze, as the maximum parallelism is largely determined by synchronizations between subprocesses over channels. Thus, type-based analysis of the span of such processes requires a resource-aware type system with respect to the behavior of channels. While type systems for static complexity analysis have been studied extensively for sequential programs, using such notions as amortized analysis and sized types (Consider for instance \cite{AvanziniLago2017,LagoGaboardi2012,Hofmann2003,Hoffmann2010}), relatively few contributions have been made to that of concurrent programs since early work by Kobayashi \cite{Kobayashi2000} in 2000, and being inherently more complex to analyze than sequential programs, much work has yet to be done for concurrent programs. This is further exemplified by the recent resumption of research into static complexity analysis of $\pi$-calculus like languages led by two independent groups of researchers, using different notions of behavioral types \cite{BaillotGhyselen2021,BaillotEtAl2021,DasEtAl2018}. \\

The term Behavioral types does not refer to a certain type discipline, but rather to a family of type disciplines that are able to describe such notions as causality, choice and resource use \cite{Huttel2016}, starting as simple as linear types that impose linearity constraints on resources, thereby ensuring such resources are used exactly once \cite{KobayashiPierce1999}. Behavioral types are particularly useful for prescribing the behavior of message-passing processes in the study of concurrency theory. Such communication makes concurrent programs notoriously complex and possibly non-deterministic, leading to a variety of difficult problems that may affect or inhibit outcomes of programs, such as ensuring deadlock or livelock freedom, or verifying that message-passing cannot result in run-time errors. Kobayashi and Sangiorgi \cite{KobayashiSangiorgi2010} state that most liveness properties for the pure $\pi$-calculus can be reduced to ensuring lock-freedom. Behavioral type disciplines such as session types \cite{Honda1993,HondaEtAl1998} and usage types \cite{SumiiKobayashi1998} can prescribe valid communication patterns for channels in such programs, placing constraints on how concurrent processes may communicate, and have thereby been used successfully as bases for type disciplines capable of verifying some of these properties \cite{Kobayashi2000,Kobayashi2002,DardhaGay2018}.\\

% However, since the advent of behavioral types in the 1990s, types have been used to analyze various properties with regards to the run-time behavior of programs. The term Behavioral types does not refer to a certain type discipline, but rather to a family of type disciplines that are able to describe such notions as causality, choice and resource use \cite{Huttel2016}, starting as simple as Linear types that impose linearity constraints on resources, thereby ensuring such resources are used exactly once \cite{KobayashiPierce1999}.\\

%More recently, behavioral types have been used in the study of static complexity analysis, to introduce type systems for which bounds on the complexities of well-typed programs can be derived from their typings. \\


%Therefore, we find it appropriate to compile the research of this domain from the past 20 years, to make it more accessible to new researchers.\\

Behavioral type disciplines have different advantages with respect to resource-awareness, and so we find it appropriate to compare different approaches to type-based static complexity analysis. In this article, we provide a survey of some of the most relevant behavioral type disciplines and type systems for parallel complexity of $\pi$-calculus like languages from the past 20 years of research. In this regard, we define a common variant of the $\pi$-calculus, with a flexible cost model for time, for which we formally introduce and discuss behavioral type systems for parallel complexity. Specifically, we consider the early work on usage types to bound the time of synchronizations by Kobayashi \cite{Kobayashi2000}, as well as the use of sized types to bound the time of \textit{recursive} processes used in conjunction with Input/Output and Usage types by Baillot and Ghyselen \cite{BaillotGhyselen2021} and Baillot et al. \cite{BaillotEtAl2021}, respectively. Finally, we consider a novel approach by Das et al. \cite{DasEtAl2018} that uses temporal session types to prescribe timed protocols, enabling analysis of such properties as the rate, latency and complexity of communication. We prove a type preservation result for the type system by Das et al. and conjecture that the type system bounds the span of well-typed processes. As a comparison taxonomy for the type systems, we consider the expressiveness and precision of the type systems, as well as the current state of \textit{time reconstruction} for the respective type disciplines. \\

%\input{sections/relatedwork}
%
The remainder of this article is organized as follows. We first discuss related work in Section \ref{sec:relatedwork}, afterwhich we review the variant of the $\pi$-calculus for which we discuss type disciplines and type systems in Section \ref{sec:picalc}. Then in Section \ref{sec:usages}, we introduce usages and the corresponding type system by Kobayashi \cite{Kobayashi2000}. In Section \ref{sec:sizedtypes} we consider sized types for parallel complexity, and in Section \ref{sec:usagessized} we extend usages with sized types and introduce the corresponding type system by Baillot et al. \cite{BaillotEtAl2021}. Then in Section \ref{sec:sessiontypes}, we introduce session types and show how Das et al. \cite{DasEtAl2018} extend session types with temporal modalities, afterwhich we conjecture the soundness of the session type system. Finally, we compare the type systems and discuss future work in in Section \ref{sec:conc}. 