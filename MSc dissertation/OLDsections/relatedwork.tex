% https://link.springer.com/content/pdf/10.1007%2F978-3-030-17184-1_21.pdf (timed session types)

\section{Related work}\label{sec:relatedwork}
%
Several contributions have been made to the study of type-based complexity analysis of time for functional languages \cite{DalLago2009,AvanziniLago2017,DalLagoGaboardi2011}. Notably, Avanzini and Dal Lago \cite{AvanziniLago2017} bound the complexity of higher-order functional programs by a three-step approach. They first introduce a type system for sized types akin to that of Hughes et al. \cite{HughesEtAl1996} but allow second-order polymorphism resulting in a type system that is more expressive, but does not guarantee termination. The type system generates a second-order constraint problem that can be reduced to first-order and subsequently be solved, enabling inference of the sizes of data structures. Avanzini and Dal Lago utilize this to bound the time complexity by defining a transformation for programs that preserves behavior while lifting functions into a state monad that carries a data structure representing a clock that ticks corresponding to program reductions. The sized type of the clock thus yields a bound on the complexity.\\

Related to this is type-based complexity analysis with respect to space. Hoffmann and Hofmann \cite{Hoffmann2010} introduce a type system for an OCaml esque language where bounds on the spacial resource use of well-typed programs can be derived from their typings. They use the potential method of amortized analysis to better account for interactions between reduction steps, thereby providing more precise bounds on the complexity of data structures as compared to addition of worst-case resource bounds of individual steps. The approach works by annotating data types for data structures of variable length with polynomial potentials that can be used to \textit{pay} for operations performed on said data structures. The type system introduces linear constraints on what these potentials should be, enabling inference of bounds on the space complexities of many practical programs.\\

Hoffmann and Shao \cite{HoffmannShao2015} introduce a similar type system but for time complexity that extends the potential method to parallel programs. Simply assigning the same potential to both subprograms of a parallel composition breaks the compositionality of amortized analysis, as it is unclear what the remainining potential of the parallel composition should be. Hoffmann and Shao preserve compositionality by instead performing two type-based analyses (one for each subprogram) sharing the same initial potential. The type system additionally uses sized types to reason about the sizes of recursive data structures, enabling precise bounds on the time complexities of many programs. However, parallel subprograms cannot communicate, and so to the best of our knowledge, we have yet to see type-based amortized analysis for $\pi$-calculus esque languages.\\

Another area of research related to type-based complexity analysis is that of liveness or termination analysis. That is, the halting problem is essentially a simplification of time complexity, in that a finite complexity implies termination whereas an infinite complexity implies non-termination. A key difference is that type systems for complexity typically provide upper bounds on the complexity (as we have seen), and so a program with an infinite bound on its time complexity may still terminate. Hughes et al. \cite{HughesEtAl1996} introduce a sized type based type system for analyzing such properties as termination for primitively recursive functional programs. The type system enforces recursion to be on data structures that decrease in size, thus guaranteeing termination. Note that the type systems by Baillot and Ghyselen \cite{BaillotGhyselen2021} and Baillot et al. \cite{BaillotEtAl2021} that we have considered provide particularly precise bounds on many primitive recursive \textit{functions}, by the use of sized types. Such types are less useful for more complex recursive functions, and in the general sense, complexity analysis for Turing-complete languages is an undecidable problem.\\

Within the topic of liveness analysis, deadlock-freedom properties of message-passing processes are studied. This relates to complexity analysis in that type systems for deadlock-freedom are very similar to those used for type-based complexity analysis. That is, both usages and session types are useful for analyzing deadlock-freedom (as we have seen), as this also requires resource awareness with respect to message-passing. Dardha and PÃ©rez \cite{DardhaPerezComparison} formally compare the expressiveness of type systems based on usages and session types in the style of Caires and Pfenning \cite{CairesPfenning2010} in the study of deadlock-freedom. They prove that the usage based type system is strictly more expressive than the one based on session types, which we have speculated to also be the case in the study of type-based complexity analysis. 

%%