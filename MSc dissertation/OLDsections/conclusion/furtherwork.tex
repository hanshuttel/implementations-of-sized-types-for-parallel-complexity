\section{Future work}

As already mentioned, the type systems for parallel complexity that we have considered in this paper do not have formalized algorithms for type inference, despite such algorithms already existing for the underlying type disciplines (Consider e.g. Padovani's work on type inference for context-free session types \cite{Padovani2017} and inference for sized types by Hughes et al. \cite{HughesEtAl1996}). An obvious next step would therefore be to introduce type inference algorithms for the individual type systems.\\%, to ensure that no additions of the type systems make typing undecidable.\\

A shortcoming we found of the type system based on session types, is that the complexity bounds provided by this type system tend to be infinite because of temporal modalities $\Box$ (always) and $\lozenge$ (eventually). This is due to the fact that these often show up when typing recursive processes, which cannot be bounded by the type system. Exploring the possibility to bound these recursive processes using sized types, as in Baillot and Ghyselen \cite{BaillotGhyselen2021} and Baillot et al. \cite{BaillotEtAl2021} is also an intriguing next step.\\

Of course, more precise bounds is always desired. While it will never be possible to infer exact bounds for all programs, as this would solve the halting problem, we still believe it is possible to get more precise bounds than state-of-the-art type systems currently provide. We saw in example \ref{sec:sizedwithusagesexample}, that we must assign larger obligations and capacities to usages than desired, in order to make them reliable. In our case this resulted in us being forced to use a capacity of infinity, even though we can see that this is a vast over-approximation of the actual process. This seems to be due to the fact that whereas the type system can tell an upper-bound on the number of recursive calls, using sized types and constraints, the reliability check of usages does not have this information available. Exploring ways to expose and use this information during the reliability check of usages, in a sound manner, seems to be an interesting next step. One approach might be to tag replicated usages with an upper bound on the number of replications, such that this can be used during the reduction of usages. With that follows the need for proofs that this would preserve soundness of the type system. Additionally, processes exist that can be given a finite complexity bound, but where the actual bound is tighter than the one given by the type system.\\

Two major approaches we have explored for addressing time is usages and temporal session types. To understand the relationship between these even better, it would be intriguing to more formally describe equivalences or relationships between these. Finally, we have discussed the missing soundness results with respect to span in Das et al., and we have formed a conjecture stating that the type system provides an upper bound on the span of a well-typed processes. Due to time limitations, this conjecture has yet to be proven, and remains as future work.